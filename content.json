{"meta":{"title":"FT-JOHN","subtitle":"区块链项目落地探索","description":"","author":"FT-JOHN","url":"https://ft-john.github.io","root":"/"},"posts":[{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"CBDC","slug":"CBDC","permalink":"https://ft-john.github.io/tags/CBDC/"},{"name":"央行数字货币","slug":"央行数字货币","permalink":"https://ft-john.github.io/tags/%E5%A4%AE%E8%A1%8C%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"},{"name":"DCEP","slug":"DCEP","permalink":"https://ft-john.github.io/tags/DCEP/"}],"title":"DCEP 央行法定数字货币技术解析（二）：D币的印制与发行","date":"2019/12/27","text":"央行印制科学技术研究所央行数字货币的科研任务主要由四家旗下机构承担：中国人民银行数字货币研究所、中国人民银行印制科学技术研究所、中钞信用卡产业发展有限公司杭州区块链技术研究院以及中钞信用卡产业发展有限公司北京智能卡技术研究院。其中中国人民银行印制科学技术研究所是中国印制行业唯一的科研机构，从事印钞应用基础研究、印钞新材料研究、印钞专用设备设计与研究、印钞及制版工艺研究，以及钞券鉴别仪器与其它防伪相关技术研究等，是国家指定的有价证券真伪鉴别权威机构。 上文说道，DCEP数字货币是对M0纸币的数字化，类似纸币中的制造工艺、防伪等技术研究，也主要由印制科技技术研究所承担。该单位申请的数字货币相关专利中（目前为止共22项），大都集中在数字货币的构成、发行、存储与转移（交易）等方面。从这些专利文档中，我们可以一窥央行数字货币的具体形态、存储方式、安全机制、双离线交易方案。 术语与缩写在印制科学技术研究所的相关专利文档中，采用了一系列的专有单词或符号来表示一些特定的名词，为了描述方便，本文中也参照采用同样的缩写方式。现提前说明如下： D-RMB：基于密码数字的人民币数字货币体系，如 “D-RMB系统” D币: 指具体的数字货币资产，如 “D币交易” D币1、D币5、D币10、D币20、D币50、D币100: 固定面值的D币资产，如D币100表示面值为100元的D币 DCEP数字货币是如何“印制”出来的？央行在设计数字货币时，参照了纸币的特性，定义了以下需要满足的特征： 安全性：能防止商务中的任意一方更改或非法使用数字货币； 不可重复花费性：数字货币只能使用一次，重复花费能被容易地检查出来； 可控匿名性：银行和商家相互勾结也不能跟踪数字货币的使用，要求系统无法将电子现金的用户的购买行为联系到一起，从而隐蔽数字货币用户的购买历史，但数字货 币的发行方可跟踪数字货币的使用； 不可伪造性：用户不能伪造假的数字货币； 公平性：支付过程是公平的，保证要么双方交易成功，要么双方都没有损失，防 止某一交易方在交易中蒙受损失； 兼容性：D-RMB系统中数字货币的发行流程与流通环节尽可能参照实物货币发 行与流通。 D币是人民币纸币的数字化货币，与纸币具有同等的法律地址，要能与纸币一起流通。所以D币的生产流程也与纸币类似： 设计：纸币在印制前需要进行设计，确定面额、图案、防伪等内容；而D币也需要提前设计数字货币的数据结构、安全机制。 印制：纸币完成设计后，需要根据央行的统筹规划，印刷不同面额指定金额的货币；D币也需要有特定的“生产”过程。 发行：纸币印制完成后，基于业务规则，通过央行与各级商业银行向市场投放；D币也有类似的“分发”过程。 以下进行逐一介绍DCEP的实现方案。 1、D币的设计与“印制”目前已经面世的区块链加密数字资产，主要由两种模式构成：以比特币为代表的UTXO模式与以以太坊为代表的账式+余额模型。 比特币模式与纸币系统有点类似，通过转移资产的属主（拥有者）来实现加密资产的流转。不同的地方是BTC是需要记录完整的交易历史过程并可进行追溯，而纸币交易本身是不记录不可追溯的；比特币交易过程中资产是可拆分的（可拥有多个输出），而纸币具体完整性，是不可拆分。比特币的基于单位是1BTC，最小单位是10-8BTC (1聪)。 以太坊模式与商业银行体账户系类似，账本中存储了所有用户账户及其余额，发生交易后账户下的余额会实时更新。不同的地方是银行账本记录是实名制的而ETH是匿名（或者叫做“假名”）；银行账本是集中存储的，使用银行信用作为背书；而ETH账本是分布式存储，链上所有节点，共同维护，共同背书。以太坊的基本单位是1ETH，最小单位是10-18ETH（1 Wei）。 应该是考虑到与现有货币系统的兼容性，D币在设计上尽量模拟纸币，主要的设计与生产思路如下： D币由1元、5元、10元、20元、50元、100元等基本单元构成，分别定义为D币1、D币5、D币10、D币20、D币50、D币100； 央行先定义一个D币的主密码，再由主密码与数字1、5、10、20、50和100分别产生六个基本加密密码； 由哈希算法产生系统随机数，随机数可以理解为冠字号码； 由代表不同币值的基本加密密码与随机数加密，生成加密密码； 由央行私钥对加密密码进行签名（可理解为防伪机制，如水印），代表新币产生，完成“印制”过程。 由以上可见，D币拥有“面值”、拥有“冠字号”、拥有“水印”，其特征并不像目前的区块链加密货币，而是与纸币非常类似。 2、D币的发行D币完成“印制”后，接下来要进行的工作就是“发行”，而发行则依赖于D-RMB系统。D-RMB系统由以下几部分构成： 一种币：D币 两类库： 发行库：央行的数字货币基金 银行库：商业银行的库存数字现金 三个中心： 登记中心：负责货币产生、流通、清点核算以及消亡的全过程记录，主要由数字货币权属登记表与交易流水表两个账本组成 CA认证中心：基于PKI体系，对机构与用户证书进行集中管理，如CFCA（中国金融认证中心） IBC认证中心：基于标识的密码技术建立的认证中心(Identity - Based Cryptograph)，使用卡号、手机号等标识做为用户公钥（账号），再将公钥通过指定的密码设备计算出私钥，分发给用户 在D-RMB系统中，D币的发行流程如下： 根据数字货币发行总量，央行统一生成数字货币，存放在央行发行库中 商业银行在D-RMB系统提交数字货币的需求申请，在完成一系列的业务规则后（如商业银行向央行缴纳100%准备金），指定数量的数字货币从发行库转移到银行库 在登记中心，这些数字货币对应的属主由央行改为商业银行，并记录相应操作流水等信息 用户申请提取数字货币时，商业银行经过一系列的复核验证业务规则后（如验证用户身份、确认用户银行账户余额是否足够、在银行账户中扣减相应的金额），指定数量的数字货币从银行库到用户的用户电子钱包中 在登记中心，这些数字货币对应的属主由商业银行改为用户，并记录相应操作流水等信息 总结从设计上来看，DCEP数字货币与纸币非常类似，拥有“面值”、拥有“冠字号”、拥有“水印”，每个币都具有唯一性、不可分割性。通过D-RMB系统以中心化的方式来记录D币属主的变更及所有交易记录。可以确定的性，在货币发行层面，DCEP采用的技术方案与区块链技术有着明显、较大的差距。 至此DCEP已经完成了从“设计”、“印制”到“发行”的全过程，在后续的文章中，我将继续介绍在用户端DCEP是如何完成安全存储与离线交易等功能。 参考资料央行印制科学技术研究所相关专利","permalink":"https://ft-john.github.io/20191227-dcep2/","photos":["/images/20191218/dcep.jpg"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"CBDC","slug":"CBDC","permalink":"https://ft-john.github.io/tags/CBDC/"},{"name":"央行数字货币","slug":"央行数字货币","permalink":"https://ft-john.github.io/tags/%E5%A4%AE%E8%A1%8C%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"},{"name":"DCEP","slug":"DCEP","permalink":"https://ft-john.github.io/tags/DCEP/"}],"title":"DCEP 央行法定数字货币技术解析（一）：什么是DCEP","date":"2019/12/18","text":"近日，据《财经》杂志报道，由人民银行牵头，工、农、中、建四大国有商业银行，中国移动、中国电信、中国联通三大电信运营商共同参与的央行法定数字货币试点项目有望在深圳、苏州等地落地。 什么是DCEPDCEP是中国人民银行推出的央行法定数字货币（也就是常说的CBDC），DCEP就是中国的CBDC，全称是 Digital Currency Electronic Payment，也就是数字货币和电子支付工具。从名字上直接看，会重点关注“货币”与“支付”这两个层面。 人民银行早在2014年就开始了数字货币的研发工作，2016年，当时的人民银行行长周小川还接受过财新的专访，讨论过关于数字货币的话题。今年以来，DCEP见诸新闻的频率越来越高，我们离自己的数字货币距离也是越来越近了。 DCEP的主要特点目前，并没有任何时候介绍DCEP公开的官方文档，不过综合相关新闻以及央行相关负责人的讲话信息来看，DCEP将具备以下特点： DCEP是M0替代（纸钞的替代） DCEP并不是发行一种新的货币，而是现有纸钞的替代。它的功能和属性跟纸钞完全一样，只不过它的形态是数字化的。我们对它的定义翻译过来就是“具有价值特征的数字支付工具”，也就是“不需要账户就能够实现价值转移”。 DCEP具有无限法偿性 央行的数字货币属于法币，跟现金一样，是中央银行的负债，由中央银行进行信用担保，具有无限法偿性，就是说你不能拒绝接受DCEP。 我们看到现在私营的支付机构或平台，会设置各种支付壁垒，用微信的地方不能用支付宝，用支付宝的地方不能用微信，但对央行数字货币来说，只要你能使用电子支付的地方，就必须接受央行的数字货币。 央行数字货币的投放模式为“双层运营体系” 所谓的双层运营体系，上层是央行对商业银行，下层是商业银行对公众。央行按照100%准备金制将央行数字货币兑换给商业银行，再由商业银行或商业机构将数字货币兑换给公众。 目前商业银行和其他一些商业机构，在IT基础设施应用和服务体系上，都已经比较成熟了，在金融科技方面也积累了很多经验，人才储备也比较充分。DCEP将充分利用现有的资源，而不是去另起炉灶、重复建设。 DCEP可以实现“双离线支付” 既然DCEP是纸钞的替代，它也支持传统的纸币支付模式，即不需要网络就能支付，我们叫做 “双离线支付”，是指收支双方都离线，也能进行支付。只要你手机有电，哪怕整个网络都断了也可以实现支付。 DCEP不预设技术路线 在技术的选择上，央行不预设技术路线，所以也就不会强制采用区块链技术。按照目前的设计，由于央行数字货币将主要应用于小额零售高频场景，所以最为关键的就是满足高并发需求。根据央行官员透露的消息，定位于M0替代的央行数字货币交易系统的性能至少在30万笔/秒以上的水平。这种性能要求，当前的区块链系统很少能够达到。当然，这也不意味着区块链技术就无法运用于央行数字货币系统。 因为目前央行层面属于技术中性，这就意味着央行不会干预商业银行和商业机构的技术选择。无论下层选用区块链分布式账本技术，还是传统账户体系，央行都能接受并适应。指定运营机构可以采取不同的技术路线做相关研发，谁的路线好，谁最终会被老百姓接受、被市场接受，谁就最终会跑赢比赛，是一个“市场竞争选优的过程”。 DCEP与同类产品对比 与纸币的对比 纸币的持有与交易匿名，不好追踪；DCEP安全相对匿名，不容易被追踪，通过对交易特征的分析来识别洗钱等非法交易 纸币数量大了不好清点与携带；DECP方便清点方便携带 纸币持有不需要开户；DCEP会进行分级KYC并设置限额，小额交易可能不需要开立实名钱包 与区块链加密资产（如BTC）对比 BTC是去中心化体系，无信用背书；DCEP由央行发行，由国家信用背书 DCEP是法定货币；BTC在很多国家被承认为商品，买卖需要交税 BTC是基于区块链技术实现；而DCEP采用的是一种混合技术架构，不排斥也不仅仅使用区块链技术 与微信、支付宝对比 DCEP属于M0，微信/支付宝属于M1或M2领域 微信/支付宝使用商业银行存款货币进行结算，DCEP是用央行货币进行结算。商业银行不如央行稳定，如果破产后存在银行的钱就成了“债券”，需要在破产清算后，按“债券”比例进行赔付成真正的法币。而DCEP本身就是法币，不具有此风险。 微信/支付宝采用互联网支付；DCEP不仅支持互联网支付，同时还支持双离线支付 DCEP的技术方案虽然目前没有任何官方的DCEP技术资料，不过通过梳理与法定数字货币相关的专利信息，还是可以大致了解到DCEP可能采用的技术方案。 截至2019年9月，我们找到了央行4家机构申请的共84条专利。这4家机构分别为中国人民银行数字货币研究所（52项专利信息）、中国人民银行印制科学技术研究所（22项专利信息）、中钞信用卡产业发展有限公司杭州区块链技术研究院（6项专利信息）以及中钞信用卡产业发展有限公司北京智能卡技术研究院（4项专利信息）。 4家机构中，中国人民银行印制科学技术研究所最早于2016年3月25日申请了22项与法定数字货币相关的专利；中国人民银行数字货币研究所的专利申请集中于三个时间点：2017年6月26日提交了35项相关专利申请、2017年12月28日提交了13项相关专利申请、2018年3月26日提交了4项相关专利申请；中钞信用卡产业发展有限公司下属的两家分公司从2016年6月4日至2018年8月7日陆续有共10项相关专利申请。从专利申请时间可以看出，中国央行在法定数字货币领域的研发工作进行了有前瞻性的布局且研发时间跨度较长，为中国法定数字货币的发行做了充分准备工作。 在后续的文章中，我将结合央行的专利文档，将详细分析DCEP可能采用的技术方案。在DCEP正式面市前，希望能对它有个深入的了解，充分做好拥抱全球第一个央行法定数字货币的准备！ 参考资料 《央行穆长春讲Libra和数字货币全文》 《人民币3.0 中国央行数字货币 运行框架与技术解析》","permalink":"https://ft-john.github.io/20191218-dcep1/","photos":["/images/20191218/dcep.jpg"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Quorum","slug":"Quorum","permalink":"https://ft-john.github.io/tags/Quorum/"}],"title":"阿里云BaaS下企业以太坊（Quorum）开发实践","date":"2019/12/12","text":"环境准备 在阿里云BaaS中部署Quorum网络节点，具体可参考另一篇博文 在节点管理器中找到客户端要连接节点信息 连接地址：在节点列表中可以查看节点rpc访问链接地址（提供http与ws两种格式） 安全信息：在节点设置中可以查看或修改节点访问的用户名密码 使用客户端访问 下载geth交互控制台 MAC OS: geth_v2.2.0_darwin_amd64.tar.gz Ubuntu: geth_v2.2.0_ubuntu_amd64.tar.gz 目前只支持MacOS与Ubuntu, Windows平台下可以通过WSL（Windows Subsystem for Linux）进入Ubuntu Bash环境下访问。 使用节点的用户名和密码连接到节点RPC服务端口，启动 geth 交互控制台。geth attach http:&#x2F;&#x2F;$&#123;username&#125;:$&#123;userpassword&#125;@$&#123;noderpcaddress&#125; 连接成功后可以看到以太坊节点版本信息： 输入以下命令，测试网络：eth.blockNumbereth.accounts 命令执行结果如下，表示连接正常： 开发智能合约Quorum一直跟随着以太坊公网版本的发展，支持使用最新版本的solidity语法开发智能合约。在Quorum中智能合约执行不再消耗gas，但在区块链网络中还是会配置一个gaslimit参数，以防止智能合约可能出现性能低下甚至死循环等错误。智能合约开发方式完全与以太坊一致，可以使用remix在线开发，也可以使用VSCode等开发工具。各种常见的智能合约框架如truffle，在quorum也可以使用。 在我的Demo中，我将开发一个包含资产转移与产品溯源功能的合约，以下展示主要部分代码： 定义合约，在合约初始化时发行指定数量的token给到管理员账户：pragma solidity &gt;&#x3D;0.4.0 &lt;0.7.0;&#x2F;&#x2F;支持在方法中返回数组与结构体等类型pragma experimental ABIEncoderV2;contract traceability &#123; &#x2F;&#x2F; 初始发币金额 uint constant initTokens &#x3D; 1 * 1e6 * 1e18; &#x2F;&#x2F; 合约管理员-初始发币接收人 address public admin; constructor() public &#123; admin &#x3D; msg.sender; balances[admin] &#x3D; initTokens; &#125;&#125; 定义所需的结构体：&#x2F;&#x2F; 资产动态属性struct MetadataMapping &#123; string[] keys; mapping(string &#x3D;&gt; string) metadata;&#125;struct Asset &#123; &#x2F;&#x2F; 资产id bytes32 id; &#x2F;&#x2F; 资产名称 string name; &#x2F;&#x2F; 当前拥有人 address ownership; &#x2F;&#x2F; 资产其他动态属性 MetadataMapping metadata;&#125;struct Batch &#123; bytes32 id; &#x2F;&#x2F; 发货方 address sender; &#x2F;&#x2F; 物流方 address transporter; &#x2F;&#x2F; 收货方 address receiver; &#x2F;&#x2F; 物流费用，可选 uint shipReward; &#x2F;&#x2F;token转移数量，可选 uint tokenReward; &#x2F;&#x2F; 状态，1-Created, 2-sent, 3-logisticReceived, 4-logisticSent, 5-received uint status; &#x2F;&#x2F; 发货时间 uint256 sendTime; &#x2F;&#x2F; 物流收货时间 uint256 logisticReceiveTime; &#x2F;&#x2F; 物流发货时间 uint256 logisticSendTime; &#x2F;&#x2F; 收货时间 uint256 receiveTime; &#x2F;&#x2F; 包含的资产明细id bytes32[] assetList;&#125;&#x2F;&#x2F; 资产历史动态追踪struct Track &#123; bytes32 id; &#x2F;&#x2F; 资产id bytes32 assetId; &#x2F;&#x2F; 当前拥有人 address ownership; &#x2F;&#x2F; 当前动态，1-CreateAsset, 2-CreateBatch, 3-Send, 4-LogisticReceive, 5-LogisticSend, 6-Receive uint action; &#x2F;&#x2F; 备注 bytes remark; &#x2F;&#x2F; 动态发生时间 uint256 timestamp;&#125; 定义回调事件（Event）：event TokenSent(address from, address to, uint amount);event AssetCreated(address ownership, bytes32 assetId);event BatchCreated(address sender, bytes32 batchId);event BatchSent(address sender, bytes32 batchId);event BatchReceived(address receiver, bytes32 batchId); 实现Token管理方法：&#x2F;&#x2F;&#x2F; @notice token转账&#x2F;&#x2F;&#x2F; @param receiver 收款人&#x2F;&#x2F;&#x2F; @param amount 转账金额function sendToken(address receiver, uint amount) public &#123; require(amount &lt;&#x3D; balances[msg.sender], &quot;Insufficient balance.&quot;); balances[msg.sender] -&#x3D; amount; balances[receiver] +&#x3D; amount; emit TokenSent(msg.sender, receiver, amount);&#125;&#x2F;&#x2F;&#x2F; @notice 获取当前账户token余额&#x2F;&#x2F;&#x2F; @return 当前余额function getBalance() public view returns (uint) &#123; return balances[msg.sender];&#125; 实现资产（产品）创建、转移、追踪管理等功能： &#x2F;&#x2F;&#x2F; @notice 创建资产 &#x2F;&#x2F;&#x2F; @param name 资产名称 &#x2F;&#x2F;&#x2F; @param keys 动态属性名 &#x2F;&#x2F;&#x2F; @param values 动态属性值 &#x2F;&#x2F;&#x2F; @return 新资产id function createAsset(string memory name, string[] memory keys, string[] memory values) public returns (bytes32) &#123; require(keys.length &#x3D;&#x3D; values.length, &quot;keys and values not matched&quot;); bytes32 id &#x3D; getUniqueId(1, assetSize, msg.sender); assets[id].id &#x3D; id; assets[id].name &#x3D; name; assets[id].ownership &#x3D; msg.sender; assets[id].metadata.keys &#x3D; keys; assetSize ++; for(uint i &#x3D; 0; i &lt; keys.length; i ++) &#123; assets[id].metadata.metadata[keys[i]] &#x3D; values[i]; &#125; assetIds.push(id); saveTrack(id, msg.sender, 1, empty); emit AssetCreated(msg.sender, id); return id; &#125; &#x2F;&#x2F;&#x2F; @notice 创建batch &#x2F;&#x2F;&#x2F; @param transporter 物流方地址 &#x2F;&#x2F;&#x2F; @param receiver 收货方地址 &#x2F;&#x2F;&#x2F; @param shipReward 物流费用，可为0 &#x2F;&#x2F;&#x2F; @param tokenReward Token转移金额，可为0 &#x2F;&#x2F;&#x2F; @param assetList 资产明细id &#x2F;&#x2F;&#x2F; @return batch id function createBatch(address transporter, address receiver, uint shipReward, uint tokenReward, bytes32[] memory assetList) public returns (bytes32) &#123; require((shipReward + tokenReward) &lt;&#x3D; balances[msg.sender], &quot;Insufficient balance.&quot;); bytes32 id &#x3D; getUniqueId(2, batchSize, msg.sender); batches[id] &#x3D; Batch(id, msg.sender, transporter, receiver, shipReward, tokenReward, 1, now, 0, 0, 0, assetList); batchSize ++; balances[msg.sender] -&#x3D; (shipReward + tokenReward); for(uint i &#x3D; 0; i &lt; assetList.length; i ++) &#123; require(assets[assetList[i]].ownership &#x3D;&#x3D; msg.sender, &quot;Insufficient assets privileges&quot;); saveTrack(assetList[i], msg.sender, 2, abi.encodePacked(id)); &#125; emit BatchCreated(msg.sender, id); return id; &#125;&#x2F;&#x2F; 后续省略 ... 智能合约开发完成，可以在本地使用solc-js工具进行编译： 下载与安装最新的solc:sudo npm install -g solc 编译智能合约：solcjs --abi --bin .&#x2F;traceability.sol -o build 编译成功后，在build子目录下会生成对应的abi与bin文件 使用 web3.js 开发客户端应用 项目初始化，在项目目录下执行以下命令，项目目录会生成package.json文件：npm init 安装web3.js包我一开始安装的是最新的web3包（1.2.4），但发现BaaS下的Quorum连接连接不上（用户密码没有错误），会把以下错误：npm install web3 --save 然后将web3替换成0.20.7版本，发现可以正常工作： npm install web3@0.20.7 --save 连接Quorum节点：let Web3 &#x3D; require(&quot;web3&quot;);let provider &#x3D; new Web3.providers.HttpProvider(&#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#39;, &#x2F;&#x2F;rpc地址50000, &#x2F;&#x2F;超时时间（毫秒）&#39;user&#39;, &#x2F;&#x2F;用户名&#39;Abcd@1234&#39; &#x2F;&#x2F;密码);let web3 &#x3D; new Web3(provider);console.log(&quot;web3 is connected:&quot;, web3.isConnected()); 连接成功后，会输出以下日志：web3 is connected: true 部署智能合约，部署成功后会输出合约地址，需要记录下来，以备调用合约时使用：let Web3 &#x3D; require(&quot;web3&quot;);var fs &#x3D; require(&#39;fs&#39;);provider &#x3D; new Web3.providers.HttpProvider(&#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#39;, 5000, &#39;user&#39;, &#39;Abcd@1234&#39;);var web3 &#x3D; new Web3(provider);console.log(web3.isConnected());&#x2F;&#x2F; set first account to default accountvar account &#x3D; web3.eth.accounts[0];web3.eth.defaultAccount &#x3D; account;&#x2F;&#x2F; unlock default accountweb3.personal.unlockAccount(account, &quot;&quot;, 300);&#x2F;&#x2F; read abi for contractvar abi &#x3D; JSON.parse(fs.readFileSync(&quot;..&#x2F;contract&#x2F;build&#x2F;traceability_sol_traceability.abi&quot;));&#x2F;&#x2F; read bytecode for contractvar bytecode &#x3D; &quot;0x&quot; + fs.readFileSync(&#39;..&#x2F;contract&#x2F;build&#x2F;traceability_sol_traceability.bin&#39;);var address &#x3D; &quot;&quot;var simpleContract &#x3D; web3.eth.contract(abi);var simple &#x3D; simpleContract.new(&#123; from: account, data: bytecode, gas: 0x47b760&#125;, function(e, contract) &#123; if (e) &#123; console.log(&quot;err creating contract&quot;, e); &#125; else &#123; if (!contract.address) &#123; console.log(&quot;Contract transaction send: TransactionHash: &quot; + contract.transactionHash + &quot; waiting to be mined...&quot;); &#125; else &#123; &#x2F;&#x2F; get contract address from here! console.log(&quot;Contract mined! Address: &quot; + contract.address); address &#x3D; contract.address console.log(contract); &#125; &#125;&#125;); 调用合约：let Web3 &#x3D; require(&quot;web3&quot;);let fs &#x3D; require(&quot;fs&quot;);let provider &#x3D; new Web3.providers.HttpProvider(&#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#39;, 50000, &#39;user&#39;, &#39;Abcd@1234&#39;);let web3 &#x3D; new Web3(provider);console.log(&quot;web3 is connected:&quot;, web3.isConnected());let account &#x3D; web3.eth.accounts[0];web3.eth.defaultAccount &#x3D; account;web3.personal.unlockAccount(account, &quot;&quot;, 3000);&#x2F;&#x2F; abi for contractvar abi &#x3D; JSON.parse(fs.readFileSync(&quot;..&#x2F;contract&#x2F;build&#x2F;traceability_sol_traceability.abi&quot;));var contractAddress &#x3D; &quot;0x1dbaccedfe36189819d2f6029b8036f9a0ea398b&quot;;var contract &#x3D; web3.eth.contract(abi).at(contractAddress);console.log(&quot;getBalance:&quot;, contract.getBalance().toString());var assetName &#x3D; &quot;asset1&quot;;var assetKeys &#x3D; [&quot;color&quot;, &quot;weight&quot;];var assetValues &#x3D; [&quot;red&quot;, &quot;0.1kg&quot;];contract.TokenSent(&#123;a:5&#125;, function(error, result) &#123; console.log(&quot;TokenSent event&quot;); if(!error) &#123; console.log(result); &#125; else &#123; console.log(&quot;error:&quot;, error); &#125;&#125;);contract.AssetCreated(&#123;&#125;, function(error, result) &#123; console.log(&quot;AssetCreated event&quot;); if(!error) &#123; console.log(result); &#125; else &#123; console.log(&quot;error:&quot;, error); &#125;&#125;);console.log(contract.sendToken(0xf07b2cb4d766ffa81bea15b99cd459c69b9f766a, 1*1e18));console.log(&quot;getBalance:&quot;, contract.getBalance().toString());&#x2F;&#x2F; console.log(&quot;getAssetList:&quot;, contract.getAssetList());&#x2F;&#x2F; console.log(&quot;createAsset:&quot;, contract.createAsset(assetName, assetKeys, assetValues, &#123;gas:30000000&#125;));&#x2F;&#x2F; console.log(&quot;getCurrentAssetId:&quot;, contract.getCurrentAssetId().toString());&#x2F;&#x2F; console.log(&quot;getAssetInfo:&quot;, contract.getAssetInfo(0xb3a2d41842b3b53a8bf82c3aae28f6ad7a752c793715244182b7839f37f07d20));&#x2F;&#x2F; contract.createAsset(assetName, assetKeys, assetValues, &#123;&#125;, function(error, result)&#123;&#x2F;&#x2F; console.log(&quot;call CreateAsset&quot;);&#x2F;&#x2F; if(!error) &#123; &#x2F;&#x2F; console.log(&quot;result:&quot;, result);&#x2F;&#x2F; &#125; else &#123;&#x2F;&#x2F; console.log(&quot;error:&quot;, error);&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;); 合约与事件输出： 总结Quorum是在以太坊的基础上发展起来的，以太坊的开发工具链基本都可以用上，如果熟悉以太坊智能合约与web3.js开发的话，开发quorum应用也就会非常轻松。只是不知为何web3.js 1.0以上版本连接不上，看阿里云文档说明是可以支持的，此问题后面将继续跟进。Quorum本地原生部署确实比较麻烦，原代码编译不通过，文档说明也不够细致。好在阿里云BaaS平台提供了对Quorum的支持，通过BaaS可以在短时间内搭建起自己的Quorum网络。 Demo项目源码可参考：https://github.com/ft-john/quorum_demo","permalink":"https://ft-john.github.io/20191212-aliyun-quorum-2/","photos":["/20191212-aliyun-quorum-2/1.jpg"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Quorum","slug":"Quorum","permalink":"https://ft-john.github.io/tags/Quorum/"}],"title":"使用阿里云BaaS快速搭建Quorum企业以太坊网络","date":"2019/12/12","text":"Quorum 简介Quorum（企业以太坊）是由J.P.Morgan主导，在基于以太坊源码开发的一套联盟链产品。合约与应用开发模式与以太坊基本一致，以太坊的开发人员可以很容易切换到Quorum平台上面来，甚至一些以太坊上的合约、应用也可以轻松的移植过来。Quorum也得到业界的广泛关注，J.P.Morgan与Microsoft建立了紧密的合作关系，共同推广Quorum;Quorum也登录了Azure、阿里云等云服务端的BaaS平台。 Quorum与Ethereum的主要区别在于： 提供了Transaction和Contract的私有化功能 替换的共识机制，用IBFT与Raft共识取代了以太坊的PoW共识 加入了网络与节点的权限管理，从以太坊的开放式变成了许可制 交易处理性能方面得到了很大的提升Quorum 架构Quorum网络由以下几大模块构成： Quorum NodeQuorum Node 是 以太坊geth的一个轻量级的分叉，这样可以充分利用以太坊日益增大的研发社区，同时在未来也会跟着geth的版本持续升级。 Privacy ManagerQuorum提供了Tessera和Constellation新旧两种私有交易方案, Tessera目前已经可以用于生产环境，并且会持续改进升级，而Constellation只继续提供支持不再升级。Quorum的隐私管理由以下两个子模块组成： Transaction Manager: 负责管理私有交易。它存储并允许访问加密的交易数据，与其他参与者的Privacy Manager交换加密后的数据，但不能访问任何敏感的私钥。 Enclave: 用于加解密私有交易信息，与 Transaction Manager 是一对一的关系Quorum的原生部署Quorum 开发者文档中提供了两种部署方式： Docker可以通过以下命令行，拉取quorum、tessera、constellation容器模板docker pull quorumengineering&#x2F;quorumdocker pull quorumengineering&#x2F;tesseradocker pull quorumengineering&#x2F;constellation docker方式确实很方便，但是quorum文档中的介绍到此就打住了，并没有对docker配置进行详细说明，让人很难照着这个方式继续走下去…* 源代码 下载代码git clone https:&#x2F;&#x2F;github.com&#x2F;jpmorganchase&#x2F;quorum.git 编译代码, 需要先安装go运行环境cd quorummake all 运行testmake test 我卡在了编译环节，试了很多办法也走不下去，此路也不通…* 在阿里云BaaS中部署Quorum网络开通BaaS服务首先当然是要开通阿里云BaaS服务，具体参考阿里云文档 创建企业以太坊网络 登录阿里云BaaS控制台，打开“企业以太坊”下的“概览”页面： 在概览页面中点击“创建以太坊” 填写以太坊基本资料： 参数 说明 名称 以太坊网络的名称，建议填写与业务相关的名称，便于识别。 网络ID 以太坊网络的ID，创建后不能修改。 共识机制 目前只支持istanbul（IBFT）共识，暂时还未开放Raft共识。 燃料限制 GASLIMIT值，代表了这个交易的执行最多被允许使用的计算步骤。 地域 您的区块链基础设施所在的地域。建议选择与业务应用系统相同的地域。 备注 填写关于组织的其他说明。 增加节点 添加需要创建的默认节点名称。IBFT共识需要3F+1个节点，所以最少要添加4个节点。 4. 点击“创建”，开始创建以太坊网络。创建大概要花费15-40分钟进行资源配置 5. 配置完成后，在“我的以太坊”列表中可以看到新创建的Quorum网络。 ## 管理区块链网络 ### 区块链运行监控 1. 查看区块链网络监控 在“我的以太坊”列表中，点击以太坊ID，会打开Quorum区块链网络监控工具，可以看到区块链与各个节点的运行状态与实时数据。 2. 查看区块浏览器 在“我的节点”列表中，点击任意节点的“监控”操作，可以打开区块浏览器。可以查看所有的区块与交易数据。 3. 查看运行日志 在控制台左边菜单中，点击“日志”可以查看最新的运行日志。 ### 节点管理 1. 在当前用户下添加节点 在“我的以太坊”列表中，点击“增加节点”，填写节点名称与描述，即可增加一个新节点到网络中 邀请其他阿里云BaaS用户加入以太坊网络在“我的以太坊”列表中，点击“邀请”按钮，将邀请链接与邀请码发给其他阿里云BaaS用户，用户按照页面指引，一步步操作即可加入。 添加阿里云以外的Quorum节点到网络参考第一步增加节点，在填写节点信息时勾上“外部节点”选项即可。然后在“我的节点”列表中，点击节点名称，打开节点配置，修改以下节点参数： IP: Quorum 节点和节点 tx-manager 的公网IP地址 TMPort: 节点 tx-manager 的服务端口 P2pPort: Quorum 节点的 P2P 通信端口 TMPub: 节点 tx-manager 使用的身份公钥 NodePub: Quorum 节点的公钥 WSPort: 可选，Quorum 节点 websocket 服务端口 RpcPort: 可选， Quorum 节点 RPC 服务端口 设置节点安全配置在“我的节点”列表中，点击节点名称，打开节点配置而。然后在“安全设置”中设置该节点的RPC 接口的用户名和密码。以后的客户端与应用程序连接都需要用到该用户名密码。 节点投票如果新加入的节点要成为“验证节点”参与共识算法打包区块，则需要半数以上的用户投票通过。投票方法为，在节点列表中，点击该节点的“投票”操作即可。等收到足够的票数后，该节点将转成“验证节点”。 访问区块链网络至此，在阿里云上已经成功搭建好Quorum网络。客户端访问需要提供节点访问地址与安全信息（用户名、密码）。访问地址可以在“我的节点”中找到，安全信息可以在节点设置中查看或设置。","permalink":"https://ft-john.github.io/20191212-aliyun-quorum-1/","photos":["/20191212-aliyun-quorum-1/1.png"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"蚂蚁区块链","slug":"蚂蚁区块链","permalink":"https://ft-john.github.io/tags/%E8%9A%82%E8%9A%81%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"title":"阿里云BaaS下蚂蚁区块链开发实践（二）","date":"2019/12/12","text":"21 本文将继续介绍我在阿里云下基于蚂蚁区块链开发的产品溯源Demo客户端部分。蚂蚁链提供了两个平台的客户端SDK：Java与Node.js，我使用的是JS SDK。 开发前准备安装SDK 从node.js官网下载并安装 Node.js（推荐使用 v10.11.0 及以上版本）。 到链管理页面下载蚂蚁链SDK，下载的压缩包中同时包含JAVA与JS SDK。 将JS SDK alipay-mychain-0.2.27.tgz，并安装在项目目录npm i alipay-mychain-0.2.27.tgz --save 准备SSL证书文件客户端与区块链节点之间的通讯使用SSL双向加密，以保证不被中途拦截与篡改。客户端访问需要三个证书： client.key 管理员线下自行生成或在创建节点时由baas自动生成（由于服务器不保存客户端私钥，此文件只允许下载一次） client.crt 节点创建成功后，可在bass平台中的链管理界面下载 ca.crt 节点创建成功后，可在bass平台中的链管理界面下载这三个证书文件要放在客户端项目目录，以备用。创建账户蚂蚁链通过“账户”来管理客户端的访问权限，在启动开发前，需要在蚂蚁链BaaS平台的“成员管理”中，添加相应的账户。添加账户需要提交账户公钥，账户公私角可由线下生成进行提交，也可以由线上生成（由于服务器不保存账户私钥，此账户的密钥文件只允许下载一次）账户创建好后，要保存将账户私钥key文件，并将使用openssl将其转成pem格式：openssl ec -in user.key -passin pass:$&#123;key_password&#125; -passout pass:$&#123;key_password&#125; -aes256 -out user.pem 获取链节点 IP 和端口号要与合约链交互，您需要获取链节点的 IP 地址和端口号。在 BaaS 平台，通过查看目标合约链详情，在区块浏览器中查看节点详情，可获取链节点的 IP 地址和端口号。 创建与初始化SDK实例 引入JS SDKconst Chain &#x3D; require(&quot;.&#x2F;build&#x2F;index.node&quot;) 配置环境参数const fs &#x3D; require(&quot;fs&quot;)const currentUserName &#x3D; &#39;john&#39; &#x2F;&#x2F;当前账户名const userPemFolder &#x3D; &#39;john&#39;; &#x2F;&#x2F;当前账户pem文件所在目录const accountPassword &#x3D; &quot;Abcd@1234&quot; &#x2F;&#x2F;pem文件密码const passphrase &#x3D; &quot;Abcd@1234&quot; &#x2F;&#x2F; SSL证书文件密码let accountKey &#x3D; fs.readFileSync(&quot;.&#x2F;certs&#x2F;&quot; + userPemFolder + &quot;&#x2F;user.pem&quot;,&#123;encoding: &quot;utf8&quot;&#125;)let keyInfo &#x3D; Chain.utils.getKeyInfo(accountKey, accountPassword)let opt &#x3D; &#123; host: &#39;127.0.0.1&#39;, &#x2F;&#x2F;目标区块链网络节点的 IP port: 18130, &#x2F;&#x2F;端口号 timeout: 30000, &#x2F;&#x2F;连接超时时间配置 cert: fs.readFileSync(&#39;.&#x2F;certs&#x2F;client.crt&#39;, &#123;encoding: &#39;utf8&#39;&#125;), &#x2F;&#x2F;读取RSA密钥 ca: fs.readFileSync(&#39;.&#x2F;certs&#x2F;ca.crt&#39;, &#123;encoding: &#39;utf8&#39;&#125;), &#x2F;&#x2F;读取CA证书 key: fs.readFileSync(&quot;.&#x2F;certs&#x2F;client.key&quot;, &#123;encoding: &quot;utf8&quot;&#125;), &#x2F;&#x2F;读取RSA证书 userPublicKey: keyInfo.publicKey, userPrivateKey: keyInfo.privateKey, userRecoverPublicKey: keyInfo.publicKey, userRecoverPrivateKey: keyInfo.privateKey, passphrase: passphrase&#125; 初始化一个连接实例let chain &#x3D; Chain(opt) 部署智能合约下载并安装 solc-js合约编译工具由于蚂蚁区块链对 Solidity 语言的支持与原生的 Solidity 语言不同，因此不能使用外部社区的 solc-js 编译工具。只能使用BaaS 平台提供的 solc-js：alipay-solc-0.1.10.tgz 可兼容 Solidity 语言 0.4.24 版本之前的语法（不包含 0.4.24）。 下载 solc-js点击此处，获取合约编译工具 solc-js 安装包：alipay-solc-0.1.10.tgz 全局安装 solc-js全局安装 solc-js。在下载的 alipay-solc-0.1.10.tgz 所在目录执行以下命令：npm i -g alipay-solc-0.1.10.tgz 安装完成后，可以在命令行中使用solc-js 来编译合约，命令参数与原生程序基本一致。 如果需要在代码中动态编译合约，则需要按下面步骤进行安装：a. 在项目目录下npm init，将 alipay-solc-0.1.10.tgz 文件放到 项目目录b. 运行以下命令行，在项目目录中安装 solc-js：npm i alipay-solc-0.1.12.tgz --save &emsp;c. 在代码中引用solc-js:let solc &#x3D; require(&#39;@alipay&#x2F;solc&#39;) 读取并编译合约，并创建合约实例const contractName &#x3D; &#39;contractTKManager&#39;let contract &#x3D; fs.readFileSync(&#39;.&#x2F;TKManager.sol&#39;, &#123;encoding: &#39;ascii&#39;&#125;)&#x2F;&#x2F; 第二个参数设定为&quot;1&quot;，会开启编译优化 optimiserlet output &#x3D; solc.compile(contract, 1)let abi &#x3D; JSON.parse(output.contracts[&#39;:TKManager&#39;].interface)let bytecode &#x3D; output.contracts[&#39;:TKManager&#39;].bytecodelet myContract &#x3D; chain.ctr.contract(contractName, abi) 部署合约myContract.new(bytecode, &#123; from: currentUserName,&#125;, (err, contract, data) &#x3D;&gt; &#123; console.log(data) let original_block_number &#x3D; data.block_number &#x2F;&#x2F;这个是合约上链所在的区块号，需记录下来，更新合约时会用到 console.log(&#39;original_block_number:&#39;, original_block_number)&#125;) 调用智能合约蚂蚁链是通过合约名来访问智能合约的，不需要记住合约地址，这样也方便了合约的更新。因此合约一旦部署后，只需要提供合约名以及abi对象，就可以开始调用智能合约了。&#x2F;&#x2F;初始化一个连接实例let chain &#x3D; Chain(opt)let solc &#x3D; require(&#39;@alipay&#x2F;solc&#39;)let contract &#x3D; fs.readFileSync(&#39;.&#x2F;TKManager.sol&#39;, &#123;encoding: &#39;ascii&#39;&#125;)&#x2F;&#x2F; 第二个参数设定为&quot;1&quot;，会开启编译优化 optimiserlet output &#x3D; solc.compile(contract, 1)let abi &#x3D; JSON.parse(output.contracts[&#39;:TKManager&#39;].interface)let bytecode &#x3D; output.contracts[&#39;:TKManager&#39;].bytecodelet myContract &#x3D; chain.ctr.contract(contractName, abi)myContract.AddProduct(productName, modelName, description, &#123;from: currentUserName&#125;, (err, output, data) &#x3D;&gt; &#123; &#x2F;&#x2F;判断合约调用是否出错 if(typeof(err) !&#x3D; &#39;undefined&#39;) &#123; console.log(&#39;err is:&#39;, err) &#125; else &#123; &#x2F;&#x2F;调用成功，合约方法返回值可以通过 output参数获取到 console.log(&#39;output is:&#39;, output.toString()) &#125; process.exit(0)&#125;) 更新智能合约蚂蚁链的合约升级更新稍有点复杂，主要的部署是： 先将合约在本地执行模拟部署(new)，模拟部署的block_number参数应设置为合约第一次发布时所在的区块号减1，也就是发布合约时获得的参数 original_block_number - 1 本地部署完成后，会返回“runtime”字节码（bytecode） 将获得的字节码更新到链上(update)//合约第一次上链的区块号let original_block_number = 570177myContract.new(bytecode, &#123; from: currentUserName, local: true, //本地执行合约部署，目的为了模拟合约部署获取`runtime`字节码 block_number: original_block_number - 1, //防止合约id冲突 &#125;, (err, contract, data) =&gt; &#123; myContract.update(//这里注意要做替换data.receipt.output.replace('0x' + chain.EVM, ''), &#123;&#125;, (err, contract, data) =&gt; &#123; console.log(\"solidity contract has been updated\") process.exit(0) &#125;) &#125;)&#125;) 总结至此，从创建区块链网络、节点与账户，到开发智能合约，到在客户端中实现合约部署、升级以及调用，蚂蚁区块链的主要开发流程就已经介绍完了。对于蚂蚁链我的感受是，因为它与阿里云深度结合，不管是从部署、运维到合约开发、调试都是非常方便，可以节省大量的时间与成本让用户更多地关注在业务实现上。感觉不太方便的地方是支持的solidity版本太旧，智能合约的更新有点复杂不太好理解，希望能看到它持续进步。 完整Demo代码请参考：https://github.com/ft-john/antblockchain_demo","permalink":"https://ft-john.github.io/20191212-antchain-2/","photos":["/20191212-antchain-2/1.png"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"蚂蚁区块链","slug":"蚂蚁区块链","permalink":"https://ft-john.github.io/tags/%E8%9A%82%E8%9A%81%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"title":"阿里云BaaS下蚂蚁区块链开发实践（一）","date":"2019/12/12","text":"蚂蚁链与阿里云&emsp;&emsp;蚂蚁区块链是蚂蚁金服自主开发联盟区块链底层引擎，在阿里的强力宣传下，一直保持很高的曝光度。特别是今年的双十一，给4亿件天猫海淘商品在区块链上获得了“身份证”，实现从海外采购到国内配送的全链路溯源。蚂蚁链经过阿里内部这么多极端应用场景的锤炼，相信可以胜任大多数的企业应用场景。&emsp;&emsp;蚂蚁链目前暂时还未开源，无从了解过多的技术细节。不过经过公开的文档中可以看到底层采用的是以太坊那套技术框架，虚拟机采用的是EVM，智能合约开发使用Solidity，提供Java与JS SDK。 &emsp;&emsp;蚂蚁链也是阿里云BaaS服务支持的三大区块链引擎之一，使用阿里云BaaS，可以极大简化区块链网络的部署运维成本。当然，蚂蚁链目前没有开源，也不提供独立部署，只能通过阿里云BaaS或是蚂蚁金服下的区块链BaaS平台来进行管理。&emsp;&emsp;除了运维的支撑，阿里云BaaS也为蚂蚁链提供一个在线合约开发工具 – “Cloud IDE”。有点类似于以太坊的Remix IDE，为智能合约开发提供简单、高效的集成环境，并提供以下核心功能： 合约编辑与编译，展示编译结果字节码和接口说明（ABI）。 合约的部署和调用；提供默认体验链环境和测试账户，用来部署和调用合约。 解析合约方法的返回值、事件日志等，辅助调试合约； 保存合约工程到 BaaS 合约工程管理。 在前段时间，我有机会体验了阿里云BaaS服务，尝试照着文档开发了一个蚂蚁链的Demo应用。现把主要的开发步骤与心得记录下来，与大家共享。 创建蚂蚁链网络通过BaaS可以很方便创建联盟，建立区块链网络，详细操作可以参考阿里云官方文档或我的上一篇博客。 蚂蚁链智能合约蚂蚁链虽使用solidity作为智能合约的开发语言，但使用时与以太坊最新原生的solidity语法有不少差别： 蚂蚁链只支持到solidity 0.4.23及以下版本，不支援solidity最新的语法特性； 由于蚂蚁区块链对 Solidity 语言的支持与原生的 Solidity 语言不同，因此不能使用外部社区的 solc-js 编译工具。只能使用BaaS 平台提供的 专用solc-js 蚂蚁区块链合约平台基本支持 Solidity 所有的数据类型，但是对于一些用户编写的合约的输入参数类型并没有完全的支持，比如参数输入中二维数组的输入。 蚂蚁区块链合约平台提供了 identity 类型来标注每一个用户的身份，不支持原生 Solidity 中的 address 类型，identity 的长度为 32 字节。 蚂蚁区块链也提供了一些合约中的原生函数，具体可参考阿里云文档 Demo 功能介绍我实现的Demo主要目标是建立一套简单的产品溯源系统，模拟对产品从商家生产、物流运输到最终商场销售进行全流程查询与追踪。Demo中主要包含以下角色与功能： 生产商：manufacturer 创建产品 创建批次 创建批次 创建订单 查询订单状态 产品批次溯源 运输商：transporter 运送订单 签收订单（中途站） 记录订单途经位置 零售商：retailer 签收订单 更新库存 查询库存 售出产品 查询售出记录 产品批次溯源 管理员：admin 创建用户，设置用户角色 查询用户及其角色合约实现由于蚂蚁链合约开发语言与原生solidtiy有一定的差异，使用原生的solcjs编译会出各种问题，并且错误提示也不完整。因此强烈建议使用阿里云Cloud IDE开发合约。使用方法是在“联盟管理”中可以看到“合约工程管理”，然后新建或编辑现有合约工程即可。 创建所需的枚举与结构体 //用户角色enum UserRole &#123; manufacturer, transporter, retailer, admin&#125;//订单状态enum OrderState &#123; created, transporting, finished&#125;//用户结构体struct User &#123; identity account; string name; UserRole role; string companyName; string companyAddress;&#125;//产品结构体struct Product &#123; string name; string modelNumber; string manufacturerName; string description;&#125;//批次结构体struct Batch &#123; string batchNumber; string modelNumber; uint32 quantity; uint256 timestamp;&#125;//订单结构体struct Order &#123; string orderNumber; string manufacturerName; string retailerName; OrderState state; string batchNumber; string modelNumber; uint32 quantity; uint256 timestamp;&#125;//订单状态struct OrderStatus &#123; string orderNumber; OrderState status; uint256 timestamp; string userAccount; string companyName; string companyAddress;&#125;//库存结构体struct Inventory &#123; string batchNumber; string modelNumber; string orderNumber; uint64 quantity; uint256 timestamp;&#125;//销售记录struct SaleRecord &#123; string batchNumber; string modelNumber; uint64 quantity; uint256 timestamp; string userAccount;&#125;//订单状态struct MyOrderStatus &#123; mapping(uint =&gt; OrderStatus) statusList; uint statusSize;&#125;//销售历史清单struct MySoldList &#123; mapping(uint =&gt; SaleRecord) saleRecordList; uint soldSize;&#125; 定义管理员，将发布合约的用户定义为管理员，管理员可以设置分配其他用户权限 identity admin; constructor() public&#123; admin &#x3D; msg.sender;&#125;&#x2F;&#x2F; modifiermodifier onlyAdmin() &#123; require(msg.sender &#x3D;&#x3D; admin,&quot;Permission denied&quot;); _;&#125; 添加管理员相关方法 &#x2F;&#x2F;添加或设置用户基本信息function setUser(identity _account, string _name, uint256 _role, string _companyName, string _companyAddress) public onlyAdmin returns(bool) &#123; userList[_account] &#x3D; User(_account, _name, UserRole(_role), _companyName, _companyAddress); return true;&#125;&#x2F;&#x2F;获取用户基本信息function getUser(identity _account) public onlyAdmin returns(identity, string, UserRole, string, string) &#123; var user &#x3D; userList[_account]; return (user.account, user.name, user.role, user.companyName, user.companyAddress);&#125; 为其他用户添加业务方法 &#x2F;&#x2F;添加产品 function AddProduct(string _name, string _modelNumber, string _description) public returns(bool) &#123; var user &#x3D; userList[msg.sender]; productList[_modelNumber] &#x3D; Product(_name, _modelNumber, user.companyName, _description); return true; &#125;&#x2F;&#x2F;其他省略 ... 一点感受蚂蚁链不支持最新的solidity语法，开发起来会有些不方便。使用Cloud IDE开发可以快速编译、检查代码问题，并且能直接发布到测试网络上进行测试，确实能提高效率。另一个需注意的地方是，蚂蚁链不支持address类型，取而代之是identity类型，从msg.sender中取出也就是当前用户的identity数据。蚂蚁链的用户体系需要先在BaaS中创建，每个用户有一个用户名。合约中无法使用用户名，只能使用identiyt。而identity就是这个用户名的hash结果，可以通过SDK中辅助工具类中getHash方法，将用户名转成identity. 如Chain.utils.getHash(&#39;Tester001&#39;) //通过账户 name，计算得到账户的 identity完整Demo代码请参考：https://github.com/ft-john/antblockchain_demo","permalink":"https://ft-john.github.io/20191212-antchain-1/","photos":["/20191212-antchain-1/1.jpeg"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}],"title":"使用阿里云BaaS服务快速构建企业区块链服务","date":"2019/12/12","text":"联盟链与BaaS区块链技术自2008年随着比特币面市以来，以其去中心化、匿名可信、可追溯、不可篡改等特性，受到社会的广泛关注，被誉为“第三代互联网”。区块链根据其适用的不同场景，被区分为公有链、联盟链（许可链）与私有链。目前公有链产品，如BTC、ETH、EOS等主要应用在加密数字货币领域；而联盟链与私有链主要应用在政府、企业的一些去中心化业务场景中，如供应链金融、产品溯源、版权保护等等。 联盟链与公有链的主要区别在于： 用户群体不一样：公有链的用户群面向所有人，而联盟链只面向一定数量且业务相关联的机构开放 公有链中不需要验证用户身份、匿名访问；而联盟链是准入制，需要核实用户身份后才允许加入 公有链用户数量大、节点数量多、地域分布广泛；联盟链用户数量与节点数量较少、地域相对比较集中 相比公有链，联盟链对区块链服务的可靠定性、扩展性、响应速度以及数据的安全性要求比较高 公有链节点安装运行比较简单，联盟链节点安装、部署、配置很复杂 … 因着企业级应用对区块链网络的高标准要求，联盟链的运维难度与成本也很高。而BaaS（Blockchain as a Service，简称BaaS）是一种基于云计算的区块链技术平台服务，可以帮助企业快速构建更稳定、安全的生产级区块链环境，大幅减少在区块链部署、运维、管理、应用开发等方面的挑战，使企业更专注于核心业务创新，并实现业务快速上链。 阿里云BaaS服务介绍阿里云近年来发展迅猛，已经占据全球云计算市场前三的份额。阿里云也在国内较早提供BaaS服务的云计算企业，具有多种区块链技术引擎支持、一键式部署、租户数据隔离与可跨地域等特性。目前阿里云BaaS服务主要提供对以下主流区块链引擎的支持： Hyperledger Fabric，是由Linux基金会托管的开源企业级区块链技术，是开放式、标准化的区块链技术生态的代表。 企业以太坊Quorum，是摩根大通（J.P. Morgan）基于以太坊开发的面向企业场景、符合EEA（Enterprise Ethereum Alliance）规范的开源企业级区块链技术。 蚂蚁区块链，是蚂蚁金服自主研发的高性能、全球部署、极强隐私保护的金融级联盟区块链技术。 快速搭建蚂蚁区块链服务实战阿里云BaaS控制台提供了一套功能强大的区块链网络管理界面，管理员可以很容易在阿里云上构建一套区块链网络。接下来以蚂蚁区块链为例，演示一下区块链网络的搭建过程。 登录阿里云控制台，进入“区块链服务” 在左边菜单中，展开“蚂蚁区块链”，并选择合约链（蚂蚁区块链之前分为存证链与合约链两款产品，合约链基本涵盖了存证链的功能，在合约链正式上线后存证链也从BaaS中移除了。） 首先点击“创建联盟”按钮创建区块链联盟在右边弹框中填写联盟信息 联盟创建后，点击联盟列表中的“管理”操作，进入区块链管理界面。然后点击“创建区块链”按钮，创建区块链网络填写区块链网络基本信息 创建完成后，蚂蚁区块链下的“任务进度”中，可以查看区块链申请进度。一旦申请通过，就可以在区块链网络界面中看到所有区块链节点信息 至此区块链网络已经搭建完成。目前在阿里云国际站上，通过认证的企业会员可以申请蚂蚁区块链的试用。国内站已经开始收费了，如果想试用，只能加入公共的试用网络。加入方法如下： 打开“蚂蚁区块链”下的“概述”，点击申请按钮，填写申请资料： 非常重要：下载私钥并在本地保存好（只允许下载一次） 网络加入成功后，可以继续进行后继的合约开发与调试工作","permalink":"https://ft-john.github.io/20191212-aliyun-baas-1/","photos":["/20191212-aliyun-baas-1/aliyun-baas.jpeg"]}]}