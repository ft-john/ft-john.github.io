{"meta":{"title":"FT-JOHN","subtitle":"区块链项目落地探索","description":"","author":"FT-JOHN","url":"https://ft-john.github.io","root":"/"},"posts":[{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Quorum","slug":"Quorum","permalink":"https://ft-john.github.io/tags/Quorum/"}],"title":"阿里云BaaS下企业以太坊（Quorum）开发实践","date":"2019/12/12","text":"环境准备 在阿里云BaaS中部署Quorum网络节点，具体可参考另一篇博文 在节点管理器中找到客户端要连接节点信息 连接地址：在节点列表中可以查看节点rpc访问链接地址（提供http与ws两种格式） 安全信息：在节点设置中可以查看或修改节点访问的用户名密码 使用客户端访问 下载geth交互控制台 MAC OS: geth_v2.2.0_darwin_amd64.tar.gz Ubuntu: geth_v2.2.0_ubuntu_amd64.tar.gz 目前只支持MacOS与Ubuntu, Windows平台下可以通过WSL（Windows Subsystem for Linux）进入Ubuntu Bash环境下访问。 使用节点的用户名和密码连接到节点RPC服务端口，启动 geth 交互控制台。geth attach http:&#x2F;&#x2F;$&#123;username&#125;:$&#123;userpassword&#125;@$&#123;noderpcaddress&#125; 连接成功后可以看到以太坊节点版本信息： 输入以下命令，测试网络：eth.blockNumbereth.accounts 命令执行结果如下，表示连接正常： 开发智能合约Quorum一直跟随着以太坊公网版本的发展，支持使用最新版本的solidity语法开发智能合约。在Quorum中智能合约执行不再消耗gas，但在区块链网络中还是会配置一个gaslimit参数，以防止智能合约可能出现性能低下甚至死循环等错误。智能合约开发方式完全与以太坊一致，可以使用remix在线开发，也可以使用VSCode等开发工具。各种常见的智能合约框架如truffle，在quorum也可以使用。 在我的Demo中，我将开发一个包含资产转移与产品溯源功能的合约，以下展示主要部分代码： 定义合约，在合约初始化时发行指定数量的token给到管理员账户：pragma solidity &gt;&#x3D;0.4.0 &lt;0.7.0;&#x2F;&#x2F;支持在方法中返回数组与结构体等类型pragma experimental ABIEncoderV2;contract traceability &#123; &#x2F;&#x2F; 初始发币金额 uint constant initTokens &#x3D; 1 * 1e6 * 1e18; &#x2F;&#x2F; 合约管理员-初始发币接收人 address public admin; constructor() public &#123; admin &#x3D; msg.sender; balances[admin] &#x3D; initTokens; &#125;&#125; 定义所需的结构体：&#x2F;&#x2F; 资产动态属性struct MetadataMapping &#123; string[] keys; mapping(string &#x3D;&gt; string) metadata;&#125;struct Asset &#123; &#x2F;&#x2F; 资产id bytes32 id; &#x2F;&#x2F; 资产名称 string name; &#x2F;&#x2F; 当前拥有人 address ownership; &#x2F;&#x2F; 资产其他动态属性 MetadataMapping metadata;&#125;struct Batch &#123; bytes32 id; &#x2F;&#x2F; 发货方 address sender; &#x2F;&#x2F; 物流方 address transporter; &#x2F;&#x2F; 收货方 address receiver; &#x2F;&#x2F; 物流费用，可选 uint shipReward; &#x2F;&#x2F;token转移数量，可选 uint tokenReward; &#x2F;&#x2F; 状态，1-Created, 2-sent, 3-logisticReceived, 4-logisticSent, 5-received uint status; &#x2F;&#x2F; 发货时间 uint256 sendTime; &#x2F;&#x2F; 物流收货时间 uint256 logisticReceiveTime; &#x2F;&#x2F; 物流发货时间 uint256 logisticSendTime; &#x2F;&#x2F; 收货时间 uint256 receiveTime; &#x2F;&#x2F; 包含的资产明细id bytes32[] assetList;&#125;&#x2F;&#x2F; 资产历史动态追踪struct Track &#123; bytes32 id; &#x2F;&#x2F; 资产id bytes32 assetId; &#x2F;&#x2F; 当前拥有人 address ownership; &#x2F;&#x2F; 当前动态，1-CreateAsset, 2-CreateBatch, 3-Send, 4-LogisticReceive, 5-LogisticSend, 6-Receive uint action; &#x2F;&#x2F; 备注 bytes remark; &#x2F;&#x2F; 动态发生时间 uint256 timestamp;&#125; 定义回调事件（Event）：event TokenSent(address from, address to, uint amount);event AssetCreated(address ownership, bytes32 assetId);event BatchCreated(address sender, bytes32 batchId);event BatchSent(address sender, bytes32 batchId);event BatchReceived(address receiver, bytes32 batchId); 实现Token管理方法：&#x2F;&#x2F;&#x2F; @notice token转账&#x2F;&#x2F;&#x2F; @param receiver 收款人&#x2F;&#x2F;&#x2F; @param amount 转账金额function sendToken(address receiver, uint amount) public &#123; require(amount &lt;&#x3D; balances[msg.sender], &quot;Insufficient balance.&quot;); balances[msg.sender] -&#x3D; amount; balances[receiver] +&#x3D; amount; emit TokenSent(msg.sender, receiver, amount);&#125;&#x2F;&#x2F;&#x2F; @notice 获取当前账户token余额&#x2F;&#x2F;&#x2F; @return 当前余额function getBalance() public view returns (uint) &#123; return balances[msg.sender];&#125; 实现资产（产品）创建、转移、追踪管理等功能： &#x2F;&#x2F;&#x2F; @notice 创建资产 &#x2F;&#x2F;&#x2F; @param name 资产名称 &#x2F;&#x2F;&#x2F; @param keys 动态属性名 &#x2F;&#x2F;&#x2F; @param values 动态属性值 &#x2F;&#x2F;&#x2F; @return 新资产id function createAsset(string memory name, string[] memory keys, string[] memory values) public returns (bytes32) &#123; require(keys.length &#x3D;&#x3D; values.length, &quot;keys and values not matched&quot;); bytes32 id &#x3D; getUniqueId(1, assetSize, msg.sender); assets[id].id &#x3D; id; assets[id].name &#x3D; name; assets[id].ownership &#x3D; msg.sender; assets[id].metadata.keys &#x3D; keys; assetSize ++; for(uint i &#x3D; 0; i &lt; keys.length; i ++) &#123; assets[id].metadata.metadata[keys[i]] &#x3D; values[i]; &#125; assetIds.push(id); saveTrack(id, msg.sender, 1, empty); emit AssetCreated(msg.sender, id); return id; &#125; &#x2F;&#x2F;&#x2F; @notice 创建batch &#x2F;&#x2F;&#x2F; @param transporter 物流方地址 &#x2F;&#x2F;&#x2F; @param receiver 收货方地址 &#x2F;&#x2F;&#x2F; @param shipReward 物流费用，可为0 &#x2F;&#x2F;&#x2F; @param tokenReward Token转移金额，可为0 &#x2F;&#x2F;&#x2F; @param assetList 资产明细id &#x2F;&#x2F;&#x2F; @return batch id function createBatch(address transporter, address receiver, uint shipReward, uint tokenReward, bytes32[] memory assetList) public returns (bytes32) &#123; require((shipReward + tokenReward) &lt;&#x3D; balances[msg.sender], &quot;Insufficient balance.&quot;); bytes32 id &#x3D; getUniqueId(2, batchSize, msg.sender); batches[id] &#x3D; Batch(id, msg.sender, transporter, receiver, shipReward, tokenReward, 1, now, 0, 0, 0, assetList); batchSize ++; balances[msg.sender] -&#x3D; (shipReward + tokenReward); for(uint i &#x3D; 0; i &lt; assetList.length; i ++) &#123; require(assets[assetList[i]].ownership &#x3D;&#x3D; msg.sender, &quot;Insufficient assets privileges&quot;); saveTrack(assetList[i], msg.sender, 2, abi.encodePacked(id)); &#125; emit BatchCreated(msg.sender, id); return id; &#125;&#x2F;&#x2F; 后续省略 ... 智能合约开发完成，可以在本地使用solc-js工具进行编译： 下载与安装最新的solc:sudo npm install -g solc 编译智能合约：solcjs --abi --bin .&#x2F;traceability.sol -o build 编译成功后，在build子目录下会生成对应的abi与bin文件 使用 web3.js 开发客户端应用 项目初始化，在项目目录下执行以下命令，项目目录会生成package.json文件：npm init 安装web3.js包我一开始安装的是最新的web3包（1.2.4），但发现BaaS下的Quorum连接连接不上（用户密码没有错误），会把以下错误：npm install web3 --save 然后将web3替换成0.20.7版本，发现可以正常工作： npm install web3@0.20.7 --save 连接Quorum节点：let Web3 &#x3D; require(&quot;web3&quot;);let provider &#x3D; new Web3.providers.HttpProvider(&#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#39;, &#x2F;&#x2F;rpc地址50000, &#x2F;&#x2F;超时时间（毫秒）&#39;user&#39;, &#x2F;&#x2F;用户名&#39;Abcd@1234&#39; &#x2F;&#x2F;密码);let web3 &#x3D; new Web3(provider);console.log(&quot;web3 is connected:&quot;, web3.isConnected()); 连接成功后，会输出以下日志：web3 is connected: true 部署智能合约，部署成功后会输出合约地址，需要记录下来，以备调用合约时使用：let Web3 &#x3D; require(&quot;web3&quot;);var fs &#x3D; require(&#39;fs&#39;);provider &#x3D; new Web3.providers.HttpProvider(&#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#39;, 5000, &#39;user&#39;, &#39;Abcd@1234&#39;);var web3 &#x3D; new Web3(provider);console.log(web3.isConnected());&#x2F;&#x2F; set first account to default accountvar account &#x3D; web3.eth.accounts[0];web3.eth.defaultAccount &#x3D; account;&#x2F;&#x2F; unlock default accountweb3.personal.unlockAccount(account, &quot;&quot;, 300);&#x2F;&#x2F; read abi for contractvar abi &#x3D; JSON.parse(fs.readFileSync(&quot;..&#x2F;contract&#x2F;build&#x2F;traceability_sol_traceability.abi&quot;));&#x2F;&#x2F; read bytecode for contractvar bytecode &#x3D; &quot;0x&quot; + fs.readFileSync(&#39;..&#x2F;contract&#x2F;build&#x2F;traceability_sol_traceability.bin&#39;);var address &#x3D; &quot;&quot;var simpleContract &#x3D; web3.eth.contract(abi);var simple &#x3D; simpleContract.new(&#123; from: account, data: bytecode, gas: 0x47b760&#125;, function(e, contract) &#123; if (e) &#123; console.log(&quot;err creating contract&quot;, e); &#125; else &#123; if (!contract.address) &#123; console.log(&quot;Contract transaction send: TransactionHash: &quot; + contract.transactionHash + &quot; waiting to be mined...&quot;); &#125; else &#123; &#x2F;&#x2F; get contract address from here! console.log(&quot;Contract mined! Address: &quot; + contract.address); address &#x3D; contract.address console.log(contract); &#125; &#125;&#125;); 调用合约：let Web3 &#x3D; require(&quot;web3&quot;);let fs &#x3D; require(&quot;fs&quot;);let provider &#x3D; new Web3.providers.HttpProvider(&#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&#39;, 50000, &#39;user&#39;, &#39;Abcd@1234&#39;);let web3 &#x3D; new Web3(provider);console.log(&quot;web3 is connected:&quot;, web3.isConnected());let account &#x3D; web3.eth.accounts[0];web3.eth.defaultAccount &#x3D; account;web3.personal.unlockAccount(account, &quot;&quot;, 3000);&#x2F;&#x2F; abi for contractvar abi &#x3D; JSON.parse(fs.readFileSync(&quot;..&#x2F;contract&#x2F;build&#x2F;traceability_sol_traceability.abi&quot;));var contractAddress &#x3D; &quot;0x1dbaccedfe36189819d2f6029b8036f9a0ea398b&quot;;var contract &#x3D; web3.eth.contract(abi).at(contractAddress);console.log(&quot;getBalance:&quot;, contract.getBalance().toString());var assetName &#x3D; &quot;asset1&quot;;var assetKeys &#x3D; [&quot;color&quot;, &quot;weight&quot;];var assetValues &#x3D; [&quot;red&quot;, &quot;0.1kg&quot;];contract.TokenSent(&#123;a:5&#125;, function(error, result) &#123; console.log(&quot;TokenSent event&quot;); if(!error) &#123; console.log(result); &#125; else &#123; console.log(&quot;error:&quot;, error); &#125;&#125;);contract.AssetCreated(&#123;&#125;, function(error, result) &#123; console.log(&quot;AssetCreated event&quot;); if(!error) &#123; console.log(result); &#125; else &#123; console.log(&quot;error:&quot;, error); &#125;&#125;);console.log(contract.sendToken(0xf07b2cb4d766ffa81bea15b99cd459c69b9f766a, 1*1e18));console.log(&quot;getBalance:&quot;, contract.getBalance().toString());&#x2F;&#x2F; console.log(&quot;getAssetList:&quot;, contract.getAssetList());&#x2F;&#x2F; console.log(&quot;createAsset:&quot;, contract.createAsset(assetName, assetKeys, assetValues, &#123;gas:30000000&#125;));&#x2F;&#x2F; console.log(&quot;getCurrentAssetId:&quot;, contract.getCurrentAssetId().toString());&#x2F;&#x2F; console.log(&quot;getAssetInfo:&quot;, contract.getAssetInfo(0xb3a2d41842b3b53a8bf82c3aae28f6ad7a752c793715244182b7839f37f07d20));&#x2F;&#x2F; contract.createAsset(assetName, assetKeys, assetValues, &#123;&#125;, function(error, result)&#123;&#x2F;&#x2F; console.log(&quot;call CreateAsset&quot;);&#x2F;&#x2F; if(!error) &#123; &#x2F;&#x2F; console.log(&quot;result:&quot;, result);&#x2F;&#x2F; &#125; else &#123;&#x2F;&#x2F; console.log(&quot;error:&quot;, error);&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;); 合约与事件输出： 总结Quorum是在以太坊的基础上发展起来的，以太坊的开发工具链基本都可以用上，如果熟悉以太坊智能合约与web3.js开发的话，开发quorum应用也就会非常轻松。只是不知为何web3.js 1.0以上版本连接不上，看阿里云文档说明是可以支持的，此问题后面将继续跟进。Quorum本地原生部署确实比较麻烦，原代码编译不通过，文档说明也不够细致。好在阿里云BaaS平台提供了对Quorum的支持，通过BaaS可以在短时间内搭建起自己的Quorum网络。 Demo项目源码可参考：https://github.com/ft-john/quorum_demo","permalink":"https://ft-john.github.io/20191212-aliyun-quorum-2/","photos":["/20191212-aliyun-quorum-2/1.jpg"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Quorum","slug":"Quorum","permalink":"https://ft-john.github.io/tags/Quorum/"}],"title":"使用阿里云BaaS快速搭建Quorum企业以太坊网络","date":"2019/12/12","text":"Quorum 简介Quorum（企业以太坊）是由J.P.Morgan主导，在基于以太坊源码开发的一套联盟链产品。合约与应用开发模式与以太坊基本一致，以太坊的开发人员可以很容易切换到Quorum平台上面来，甚至一些以太坊上的合约、应用也可以轻松的移植过来。Quorum也得到业界的广泛关注，J.P.Morgan与Microsoft建立了紧密的合作关系，共同推广Quorum;Quorum也登录了Azure、阿里云等云服务端的BaaS平台。 Quorum与Ethereum的主要区别在于： 提供了Transaction和Contract的私有化功能 替换的共识机制，用IBFT与Raft共识取代了以太坊的PoW共识 加入了网络与节点的权限管理，从以太坊的开放式变成了许可制 交易处理性能方面得到了很大的提升Quorum 架构Quorum网络由以下几大模块构成： Quorum NodeQuorum Node 是 以太坊geth的一个轻量级的分叉，这样可以充分利用以太坊日益增大的研发社区，同时在未来也会跟着geth的版本持续升级。 Privacy ManagerQuorum提供了Tessera和Constellation新旧两种私有交易方案, Tessera目前已经可以用于生产环境，并且会持续改进升级，而Constellation只继续提供支持不再升级。Quorum的隐私管理由以下两个子模块组成： Transaction Manager: 负责管理私有交易。它存储并允许访问加密的交易数据，与其他参与者的Privacy Manager交换加密后的数据，但不能访问任何敏感的私钥。 Enclave: 用于加解密私有交易信息，与 Transaction Manager 是一对一的关系Quorum的原生部署Quorum 开发者文档中提供了两种部署方式： Docker可以通过以下命令行，拉取quorum、tessera、constellation容器模板docker pull quorumengineering&#x2F;quorumdocker pull quorumengineering&#x2F;tesseradocker pull quorumengineering&#x2F;constellation docker方式确实很方便，但是quorum文档中的介绍到此就打住了，并没有对docker配置进行详细说明，让人很难照着这个方式继续走下去…* 源代码 下载代码git clone https:&#x2F;&#x2F;github.com&#x2F;jpmorganchase&#x2F;quorum.git 编译代码, 需要先安装go运行环境cd quorummake all 运行testmake test 我卡在了编译环节，试了很多办法也走不下去，此路也不通…* 在阿里云BaaS中部署Quorum网络开通BaaS服务首先当然是要开通阿里云BaaS服务，具体参考阿里云文档 创建企业以太坊网络 登录阿里云BaaS控制台，打开“企业以太坊”下的“概览”页面： 在概览页面中点击“创建以太坊” 填写以太坊基本资料： 参数 说明 名称 以太坊网络的名称，建议填写与业务相关的名称，便于识别。 网络ID 以太坊网络的ID，创建后不能修改。 共识机制 目前只支持istanbul（IBFT）共识，暂时还未开放Raft共识。 燃料限制 GASLIMIT值，代表了这个交易的执行最多被允许使用的计算步骤。 地域 您的区块链基础设施所在的地域。建议选择与业务应用系统相同的地域。 备注 填写关于组织的其他说明。 增加节点 添加需要创建的默认节点名称。IBFT共识需要3F+1个节点，所以最少要添加4个节点。 4. 点击“创建”，开始创建以太坊网络。创建大概要花费15-40分钟进行资源配置 5. 配置完成后，在“我的以太坊”列表中可以看到新创建的Quorum网络。 ## 管理区块链网络 ### 区块链运行监控 1. 查看区块链网络监控 在“我的以太坊”列表中，点击以太坊ID，会打开Quorum区块链网络监控工具，可以看到区块链与各个节点的运行状态与实时数据。 2. 查看区块浏览器 在“我的节点”列表中，点击任意节点的“监控”操作，可以打开区块浏览器。可以查看所有的区块与交易数据。 3. 查看运行日志 在控制台左边菜单中，点击“日志”可以查看最新的运行日志。 ### 节点管理 1. 在当前用户下添加节点 在“我的以太坊”列表中，点击“增加节点”，填写节点名称与描述，即可增加一个新节点到网络中 邀请其他阿里云BaaS用户加入以太坊网络在“我的以太坊”列表中，点击“邀请”按钮，将邀请链接与邀请码发给其他阿里云BaaS用户，用户按照页面指引，一步步操作即可加入。 添加阿里云以外的Quorum节点到网络参考第一步增加节点，在填写节点信息时勾上“外部节点”选项即可。然后在“我的节点”列表中，点击节点名称，打开节点配置，修改以下节点参数： IP: Quorum 节点和节点 tx-manager 的公网IP地址 TMPort: 节点 tx-manager 的服务端口 P2pPort: Quorum 节点的 P2P 通信端口 TMPub: 节点 tx-manager 使用的身份公钥 NodePub: Quorum 节点的公钥 WSPort: 可选，Quorum 节点 websocket 服务端口 RpcPort: 可选， Quorum 节点 RPC 服务端口 设置节点安全配置在“我的节点”列表中，点击节点名称，打开节点配置而。然后在“安全设置”中设置该节点的RPC 接口的用户名和密码。以后的客户端与应用程序连接都需要用到该用户名密码。 节点投票如果新加入的节点要成为“验证节点”参与共识算法打包区块，则需要半数以上的用户投票通过。投票方法为，在节点列表中，点击该节点的“投票”操作即可。等收到足够的票数后，该节点将转成“验证节点”。 访问区块链网络至此，在阿里云上已经成功搭建好Quorum网络。客户端访问需要提供节点访问地址与安全信息（用户名、密码）。访问地址可以在“我的节点”中找到，安全信息可以在节点设置中查看或设置。","permalink":"https://ft-john.github.io/20191212-aliyun-quorum-1/","photos":["/20191212-aliyun-quorum-1/1.png"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"蚂蚁区块链","slug":"蚂蚁区块链","permalink":"https://ft-john.github.io/tags/%E8%9A%82%E8%9A%81%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"title":"阿里云BaaS下蚂蚁区块链开发实践（二）","date":"2019/12/12","text":"21 本文将继续介绍我在阿里云下基于蚂蚁区块链开发的产品溯源Demo客户端部分。蚂蚁链提供了两个平台的客户端SDK：Java与Node.js，我使用的是JS SDK。 开发前准备安装SDK 从node.js官网下载并安装 Node.js（推荐使用 v10.11.0 及以上版本）。 到链管理页面下载蚂蚁链SDK，下载的压缩包中同时包含JAVA与JS SDK。 将JS SDK alipay-mychain-0.2.27.tgz，并安装在项目目录npm i alipay-mychain-0.2.27.tgz --save 准备SSL证书文件客户端与区块链节点之间的通讯使用SSL双向加密，以保证不被中途拦截与篡改。客户端访问需要三个证书： client.key 管理员线下自行生成或在创建节点时由baas自动生成（由于服务器不保存客户端私钥，此文件只允许下载一次） client.crt 节点创建成功后，可在bass平台中的链管理界面下载 ca.crt 节点创建成功后，可在bass平台中的链管理界面下载这三个证书文件要放在客户端项目目录，以备用。创建账户蚂蚁链通过“账户”来管理客户端的访问权限，在启动开发前，需要在蚂蚁链BaaS平台的“成员管理”中，添加相应的账户。添加账户需要提交账户公钥，账户公私角可由线下生成进行提交，也可以由线上生成（由于服务器不保存账户私钥，此账户的密钥文件只允许下载一次）账户创建好后，要保存将账户私钥key文件，并将使用openssl将其转成pem格式：openssl ec -in user.key -passin pass:$&#123;key_password&#125; -passout pass:$&#123;key_password&#125; -aes256 -out user.pem 获取链节点 IP 和端口号要与合约链交互，您需要获取链节点的 IP 地址和端口号。在 BaaS 平台，通过查看目标合约链详情，在区块浏览器中查看节点详情，可获取链节点的 IP 地址和端口号。 创建与初始化SDK实例 引入JS SDKconst Chain &#x3D; require(&quot;.&#x2F;build&#x2F;index.node&quot;) 配置环境参数const fs &#x3D; require(&quot;fs&quot;)const currentUserName &#x3D; &#39;john&#39; &#x2F;&#x2F;当前账户名const userPemFolder &#x3D; &#39;john&#39;; &#x2F;&#x2F;当前账户pem文件所在目录const accountPassword &#x3D; &quot;Abcd@1234&quot; &#x2F;&#x2F;pem文件密码const passphrase &#x3D; &quot;Abcd@1234&quot; &#x2F;&#x2F; SSL证书文件密码let accountKey &#x3D; fs.readFileSync(&quot;.&#x2F;certs&#x2F;&quot; + userPemFolder + &quot;&#x2F;user.pem&quot;,&#123;encoding: &quot;utf8&quot;&#125;)let keyInfo &#x3D; Chain.utils.getKeyInfo(accountKey, accountPassword)let opt &#x3D; &#123; host: &#39;127.0.0.1&#39;, &#x2F;&#x2F;目标区块链网络节点的 IP port: 18130, &#x2F;&#x2F;端口号 timeout: 30000, &#x2F;&#x2F;连接超时时间配置 cert: fs.readFileSync(&#39;.&#x2F;certs&#x2F;client.crt&#39;, &#123;encoding: &#39;utf8&#39;&#125;), &#x2F;&#x2F;读取RSA密钥 ca: fs.readFileSync(&#39;.&#x2F;certs&#x2F;ca.crt&#39;, &#123;encoding: &#39;utf8&#39;&#125;), &#x2F;&#x2F;读取CA证书 key: fs.readFileSync(&quot;.&#x2F;certs&#x2F;client.key&quot;, &#123;encoding: &quot;utf8&quot;&#125;), &#x2F;&#x2F;读取RSA证书 userPublicKey: keyInfo.publicKey, userPrivateKey: keyInfo.privateKey, userRecoverPublicKey: keyInfo.publicKey, userRecoverPrivateKey: keyInfo.privateKey, passphrase: passphrase&#125; 初始化一个连接实例let chain &#x3D; Chain(opt) 部署智能合约下载并安装 solc-js合约编译工具由于蚂蚁区块链对 Solidity 语言的支持与原生的 Solidity 语言不同，因此不能使用外部社区的 solc-js 编译工具。只能使用BaaS 平台提供的 solc-js：alipay-solc-0.1.10.tgz 可兼容 Solidity 语言 0.4.24 版本之前的语法（不包含 0.4.24）。 下载 solc-js点击此处，获取合约编译工具 solc-js 安装包：alipay-solc-0.1.10.tgz 全局安装 solc-js全局安装 solc-js。在下载的 alipay-solc-0.1.10.tgz 所在目录执行以下命令：npm i -g alipay-solc-0.1.10.tgz 安装完成后，可以在命令行中使用solc-js 来编译合约，命令参数与原生程序基本一致。 如果需要在代码中动态编译合约，则需要按下面步骤进行安装：a. 在项目目录下npm init，将 alipay-solc-0.1.10.tgz 文件放到 项目目录b. 运行以下命令行，在项目目录中安装 solc-js：npm i alipay-solc-0.1.12.tgz --save &emsp;c. 在代码中引用solc-js:let solc &#x3D; require(&#39;@alipay&#x2F;solc&#39;) 读取并编译合约，并创建合约实例const contractName &#x3D; &#39;contractTKManager&#39;let contract &#x3D; fs.readFileSync(&#39;.&#x2F;TKManager.sol&#39;, &#123;encoding: &#39;ascii&#39;&#125;)&#x2F;&#x2F; 第二个参数设定为&quot;1&quot;，会开启编译优化 optimiserlet output &#x3D; solc.compile(contract, 1)let abi &#x3D; JSON.parse(output.contracts[&#39;:TKManager&#39;].interface)let bytecode &#x3D; output.contracts[&#39;:TKManager&#39;].bytecodelet myContract &#x3D; chain.ctr.contract(contractName, abi) 部署合约myContract.new(bytecode, &#123; from: currentUserName,&#125;, (err, contract, data) &#x3D;&gt; &#123; console.log(data) let original_block_number &#x3D; data.block_number &#x2F;&#x2F;这个是合约上链所在的区块号，需记录下来，更新合约时会用到 console.log(&#39;original_block_number:&#39;, original_block_number)&#125;) 调用智能合约蚂蚁链是通过合约名来访问智能合约的，不需要记住合约地址，这样也方便了合约的更新。因此合约一旦部署后，只需要提供合约名以及abi对象，就可以开始调用智能合约了。&#x2F;&#x2F;初始化一个连接实例let chain &#x3D; Chain(opt)let solc &#x3D; require(&#39;@alipay&#x2F;solc&#39;)let contract &#x3D; fs.readFileSync(&#39;.&#x2F;TKManager.sol&#39;, &#123;encoding: &#39;ascii&#39;&#125;)&#x2F;&#x2F; 第二个参数设定为&quot;1&quot;，会开启编译优化 optimiserlet output &#x3D; solc.compile(contract, 1)let abi &#x3D; JSON.parse(output.contracts[&#39;:TKManager&#39;].interface)let bytecode &#x3D; output.contracts[&#39;:TKManager&#39;].bytecodelet myContract &#x3D; chain.ctr.contract(contractName, abi)myContract.AddProduct(productName, modelName, description, &#123;from: currentUserName&#125;, (err, output, data) &#x3D;&gt; &#123; &#x2F;&#x2F;判断合约调用是否出错 if(typeof(err) !&#x3D; &#39;undefined&#39;) &#123; console.log(&#39;err is:&#39;, err) &#125; else &#123; &#x2F;&#x2F;调用成功，合约方法返回值可以通过 output参数获取到 console.log(&#39;output is:&#39;, output.toString()) &#125; process.exit(0)&#125;) 更新智能合约蚂蚁链的合约升级更新稍有点复杂，主要的部署是： 先将合约在本地执行模拟部署(new)，模拟部署的block_number参数应设置为合约第一次发布时所在的区块号减1，也就是发布合约时获得的参数 original_block_number - 1 本地部署完成后，会返回“runtime”字节码（bytecode） 将获得的字节码更新到链上(update)//合约第一次上链的区块号let original_block_number = 570177myContract.new(bytecode, &#123; from: currentUserName, local: true, //本地执行合约部署，目的为了模拟合约部署获取`runtime`字节码 block_number: original_block_number - 1, //防止合约id冲突 &#125;, (err, contract, data) =&gt; &#123; myContract.update(//这里注意要做替换data.receipt.output.replace('0x' + chain.EVM, ''), &#123;&#125;, (err, contract, data) =&gt; &#123; console.log(\"solidity contract has been updated\") process.exit(0) &#125;) &#125;)&#125;) 总结至此，从创建区块链网络、节点与账户，到开发智能合约，到在客户端中实现合约部署、升级以及调用，蚂蚁区块链的主要开发流程就已经介绍完了。对于蚂蚁链我的感受是，因为它与阿里云深度结合，不管是从部署、运维到合约开发、调试都是非常方便，可以节省大量的时间与成本让用户更多地关注在业务实现上。感觉不太方便的地方是支持的solidity版本太旧，智能合约的更新有点复杂不太好理解，希望能看到它持续进步。 完整Demo代码请参考：https://github.com/ft-john/antblockchain_demo","permalink":"https://ft-john.github.io/20191212-antchain-2/","photos":["/20191212-antchain-2/1.png"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"蚂蚁区块链","slug":"蚂蚁区块链","permalink":"https://ft-john.github.io/tags/%E8%9A%82%E8%9A%81%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"title":"阿里云BaaS下蚂蚁区块链开发实践（一）","date":"2019/12/12","text":"蚂蚁链与阿里云&emsp;&emsp;蚂蚁区块链是蚂蚁金服自主开发联盟区块链底层引擎，在阿里的强力宣传下，一直保持很高的曝光度。特别是今年的双十一，给4亿件天猫海淘商品在区块链上获得了“身份证”，实现从海外采购到国内配送的全链路溯源。蚂蚁链经过阿里内部这么多极端应用场景的锤炼，相信可以胜任大多数的企业应用场景。&emsp;&emsp;蚂蚁链目前暂时还未开源，无从了解过多的技术细节。不过经过公开的文档中可以看到底层采用的是以太坊那套技术框架，虚拟机采用的是EVM，智能合约开发使用Solidity，提供Java与JS SDK。 &emsp;&emsp;蚂蚁链也是阿里云BaaS服务支持的三大区块链引擎之一，使用阿里云BaaS，可以极大简化区块链网络的部署运维成本。当然，蚂蚁链目前没有开源，也不提供独立部署，只能通过阿里云BaaS或是蚂蚁金服下的区块链BaaS平台来进行管理。&emsp;&emsp;除了运维的支撑，阿里云BaaS也为蚂蚁链提供一个在线合约开发工具 – “Cloud IDE”。有点类似于以太坊的Remix IDE，为智能合约开发提供简单、高效的集成环境，并提供以下核心功能： 合约编辑与编译，展示编译结果字节码和接口说明（ABI）。 合约的部署和调用；提供默认体验链环境和测试账户，用来部署和调用合约。 解析合约方法的返回值、事件日志等，辅助调试合约； 保存合约工程到 BaaS 合约工程管理。 在前段时间，我有机会体验了阿里云BaaS服务，尝试照着文档开发了一个蚂蚁链的Demo应用。现把主要的开发步骤与心得记录下来，与大家共享。 创建蚂蚁链网络通过BaaS可以很方便创建联盟，建立区块链网络，详细操作可以参考阿里云官方文档或我的上一篇博客。 蚂蚁链智能合约蚂蚁链虽使用solidity作为智能合约的开发语言，但使用时与以太坊最新原生的solidity语法有不少差别： 蚂蚁链只支持到solidity 0.4.23及以下版本，不支援solidity最新的语法特性； 由于蚂蚁区块链对 Solidity 语言的支持与原生的 Solidity 语言不同，因此不能使用外部社区的 solc-js 编译工具。只能使用BaaS 平台提供的 专用solc-js 蚂蚁区块链合约平台基本支持 Solidity 所有的数据类型，但是对于一些用户编写的合约的输入参数类型并没有完全的支持，比如参数输入中二维数组的输入。 蚂蚁区块链合约平台提供了 identity 类型来标注每一个用户的身份，不支持原生 Solidity 中的 address 类型，identity 的长度为 32 字节。 蚂蚁区块链也提供了一些合约中的原生函数，具体可参考阿里云文档 Demo 功能介绍我实现的Demo主要目标是建立一套简单的产品溯源系统，模拟对产品从商家生产、物流运输到最终商场销售进行全流程查询与追踪。Demo中主要包含以下角色与功能： 生产商：manufacturer 创建产品 创建批次 创建批次 创建订单 查询订单状态 产品批次溯源 运输商：transporter 运送订单 签收订单（中途站） 记录订单途经位置 零售商：retailer 签收订单 更新库存 查询库存 售出产品 查询售出记录 产品批次溯源 管理员：admin 创建用户，设置用户角色 查询用户及其角色合约实现由于蚂蚁链合约开发语言与原生solidtiy有一定的差异，使用原生的solcjs编译会出各种问题，并且错误提示也不完整。因此强烈建议使用阿里云Cloud IDE开发合约。使用方法是在“联盟管理”中可以看到“合约工程管理”，然后新建或编辑现有合约工程即可。 创建所需的枚举与结构体 //用户角色enum UserRole &#123; manufacturer, transporter, retailer, admin&#125;//订单状态enum OrderState &#123; created, transporting, finished&#125;//用户结构体struct User &#123; identity account; string name; UserRole role; string companyName; string companyAddress;&#125;//产品结构体struct Product &#123; string name; string modelNumber; string manufacturerName; string description;&#125;//批次结构体struct Batch &#123; string batchNumber; string modelNumber; uint32 quantity; uint256 timestamp;&#125;//订单结构体struct Order &#123; string orderNumber; string manufacturerName; string retailerName; OrderState state; string batchNumber; string modelNumber; uint32 quantity; uint256 timestamp;&#125;//订单状态struct OrderStatus &#123; string orderNumber; OrderState status; uint256 timestamp; string userAccount; string companyName; string companyAddress;&#125;//库存结构体struct Inventory &#123; string batchNumber; string modelNumber; string orderNumber; uint64 quantity; uint256 timestamp;&#125;//销售记录struct SaleRecord &#123; string batchNumber; string modelNumber; uint64 quantity; uint256 timestamp; string userAccount;&#125;//订单状态struct MyOrderStatus &#123; mapping(uint =&gt; OrderStatus) statusList; uint statusSize;&#125;//销售历史清单struct MySoldList &#123; mapping(uint =&gt; SaleRecord) saleRecordList; uint soldSize;&#125; 定义管理员，将发布合约的用户定义为管理员，管理员可以设置分配其他用户权限 identity admin; constructor() public&#123; admin &#x3D; msg.sender;&#125;&#x2F;&#x2F; modifiermodifier onlyAdmin() &#123; require(msg.sender &#x3D;&#x3D; admin,&quot;Permission denied&quot;); _;&#125; 添加管理员相关方法 &#x2F;&#x2F;添加或设置用户基本信息function setUser(identity _account, string _name, uint256 _role, string _companyName, string _companyAddress) public onlyAdmin returns(bool) &#123; userList[_account] &#x3D; User(_account, _name, UserRole(_role), _companyName, _companyAddress); return true;&#125;&#x2F;&#x2F;获取用户基本信息function getUser(identity _account) public onlyAdmin returns(identity, string, UserRole, string, string) &#123; var user &#x3D; userList[_account]; return (user.account, user.name, user.role, user.companyName, user.companyAddress);&#125; 为其他用户添加业务方法 &#x2F;&#x2F;添加产品 function AddProduct(string _name, string _modelNumber, string _description) public returns(bool) &#123; var user &#x3D; userList[msg.sender]; productList[_modelNumber] &#x3D; Product(_name, _modelNumber, user.companyName, _description); return true; &#125;&#x2F;&#x2F;其他省略 ... 一点感受蚂蚁链不支持最新的solidity语法，开发起来会有些不方便。使用Cloud IDE开发可以快速编译、检查代码问题，并且能直接发布到测试网络上进行测试，确实能提高效率。另一个需注意的地方是，蚂蚁链不支持address类型，取而代之是identity类型，从msg.sender中取出也就是当前用户的identity数据。蚂蚁链的用户体系需要先在BaaS中创建，每个用户有一个用户名。合约中无法使用用户名，只能使用identiyt。而identity就是这个用户名的hash结果，可以通过SDK中辅助工具类中getHash方法，将用户名转成identity. 如Chain.utils.getHash(&#39;Tester001&#39;) //通过账户 name，计算得到账户的 identity完整Demo代码请参考：https://github.com/ft-john/antblockchain_demo","permalink":"https://ft-john.github.io/20191212-antchain-1/","photos":["/20191212-antchain-1/1.jpeg"]},{"tags":[{"name":"区块链","slug":"区块链","permalink":"https://ft-john.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BaaS","slug":"BaaS","permalink":"https://ft-john.github.io/tags/BaaS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://ft-john.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}],"title":"使用阿里云BaaS服务快速构建企业区块链服务","date":"2019/12/12","text":"联盟链与BaaS区块链技术自2008年随着比特币面市以来，以其去中心化、匿名可信、可追溯、不可篡改等特性，受到社会的广泛关注，被誉为“第三代互联网”。区块链根据其适用的不同场景，被区分为公有链、联盟链（许可链）与私有链。目前公有链产品，如BTC、ETH、EOS等主要应用在加密数字货币领域；而联盟链与私有链主要应用在政府、企业的一些去中心化业务场景中，如供应链金融、产品溯源、版权保护等等。 联盟链与公有链的主要区别在于： 用户群体不一样：公有链的用户群面向所有人，而联盟链只面向一定数量且业务相关联的机构开放 公有链中不需要验证用户身份、匿名访问；而联盟链是准入制，需要核实用户身份后才允许加入 公有链用户数量大、节点数量多、地域分布广泛；联盟链用户数量与节点数量较少、地域相对比较集中 相比公有链，联盟链对区块链服务的可靠定性、扩展性、响应速度以及数据的安全性要求比较高 公有链节点安装运行比较简单，联盟链节点安装、部署、配置很复杂 … 因着企业级应用对区块链网络的高标准要求，联盟链的运维难度与成本也很高。而BaaS（Blockchain as a Service，简称BaaS）是一种基于云计算的区块链技术平台服务，可以帮助企业快速构建更稳定、安全的生产级区块链环境，大幅减少在区块链部署、运维、管理、应用开发等方面的挑战，使企业更专注于核心业务创新，并实现业务快速上链。 阿里云BaaS服务介绍阿里云近年来发展迅猛，已经占据全球云计算市场前三的份额。阿里云也在国内较早提供BaaS服务的云计算企业，具有多种区块链技术引擎支持、一键式部署、租户数据隔离与可跨地域等特性。目前阿里云BaaS服务主要提供对以下主流区块链引擎的支持： Hyperledger Fabric，是由Linux基金会托管的开源企业级区块链技术，是开放式、标准化的区块链技术生态的代表。 企业以太坊Quorum，是摩根大通（J.P. Morgan）基于以太坊开发的面向企业场景、符合EEA（Enterprise Ethereum Alliance）规范的开源企业级区块链技术。 蚂蚁区块链，是蚂蚁金服自主研发的高性能、全球部署、极强隐私保护的金融级联盟区块链技术。 快速搭建蚂蚁区块链服务实战阿里云BaaS控制台提供了一套功能强大的区块链网络管理界面，管理员可以很容易在阿里云上构建一套区块链网络。接下来以蚂蚁区块链为例，演示一下区块链网络的搭建过程。 登录阿里云控制台，进入“区块链服务” 在左边菜单中，展开“蚂蚁区块链”，并选择合约链（蚂蚁区块链之前分为存证链与合约链两款产品，合约链基本涵盖了存证链的功能，在合约链正式上线后存证链也从BaaS中移除了。） 首先点击“创建联盟”按钮创建区块链联盟在右边弹框中填写联盟信息 联盟创建后，点击联盟列表中的“管理”操作，进入区块链管理界面。然后点击“创建区块链”按钮，创建区块链网络填写区块链网络基本信息 创建完成后，蚂蚁区块链下的“任务进度”中，可以查看区块链申请进度。一旦申请通过，就可以在区块链网络界面中看到所有区块链节点信息 至此区块链网络已经搭建完成。目前在阿里云国际站上，通过认证的企业会员可以申请蚂蚁区块链的试用。国内站已经开始收费了，如果想试用，只能加入公共的试用网络。加入方法如下： 打开“蚂蚁区块链”下的“概述”，点击申请按钮，填写申请资料： 非常重要：下载私钥并在本地保存好（只允许下载一次） 网络加入成功后，可以继续进行后继的合约开发与调试工作","permalink":"https://ft-john.github.io/20191212-aliyun-baas-1/","photos":["/20191212-aliyun-baas-1/aliyun-baas.jpeg"]}]}